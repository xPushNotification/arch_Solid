
    Принцип 04: INTERFACE_SEGREGATION_PRINCIPLE:
------------------------------------------------
    --  Описание принципа:
    ----------------------
    Программные сущности не должны зависеть от методов
    которые они не используют.

    Нельзя заставлять клиента реализовывать интерфейс
    которым он не пользуется
    (если это происходит - проблема в планировании интерфейсов,
    время структуру интерфейсов пересмотреть)

    Если объект находится в контексте,
    в этот контекст он приезжает с интерфейсом
    который подразумевает использование в этом контексте,
    но не больше ни меньше.

    Генерализированные решения в виде интерфейсов
    это скорее антипаттерн, чем решение проблем.

    Генерализированные интерфейсы
    разбиваются на узко специализированные
    которыми проще управлять и которые располагаясь в коде
    указывают логику объектов которые они представляют.

    Не нужно бояться делить структуру
    и делать её логически понятной
    так как структура читается ПРЕЖДЕ чем читаются контроллеры
    и именно типы под которыми действуют объекты (а не имена)
    показывают ЧТО они собираются делать и КАК их собирают использовать.
    и если уж структура поплыла логически - то никакие контроллеры
    уже её не спасут.
    (структура приводится в порядок в первую очередь, а
    основою структуры являются интерфейсы - то есть связи объектов друг с другом
    по логическим характеристикам)
    - и -
    (структура проектируется на базе интерфейсов и объектов и их типов -
    а не на базе контроллеров)
    - и -
    общий интерфейс дорога в бардак
    чем больше генерализированноо и чем меньше специализированного
    тем не понятнее программа на уровне появления новых объектов
    - и -
    генерализация связывает слишком многое со слишком многим
    разделяя эту связь код становиться менее связаным и менее абстрактным

    --  Ситуация создающая проблему:
    --------------------------------
    interface DoSomethingOne        <- подразумевали что интерфейс означает наличие и возможность 3х методов
    {
        void methodOne()
        void methodTwo()
        void methodThree()
    }
    class One implements DoSomethingOne    <- при появлении интерфейса - подложили его под этот объект
    {
        void methodOne()            <- метод используется
        void methodTwo()            <- метод используется
        void methodThree()          <- метод используется
    }
        <- система расширяется появляются еще обьекты
    class Two implements DoSomethingOne
    {
        void methodOne()            <- этот метод используется
        void methodTwo()
        void methodThree()          <- а этот метод нет в логическом смысле,
                                       но собирается использвоаться как DoSomethingOne
                                       (метод просто игнорируется или пробрасывается ошибка)
    }
    class Three implements DoSomethingOne
    {
        void methodOne()           <- этот метод используется
        void methodTwo()           <- этот уже нет
        void methodThree()         <- а этот снова используется
    }
    <- здесь система стала нестабильной
       само использование при "implements DoSomethingOne"
       уже буквально не означает ничего
       то есть "DoSomethingOne" скомпрометирован и стал не означать
       чтото абстрактно не понятное

    --  Предлагаемое решение:
    -------------------------
    Ни в коем случае не делать "implements xxx"
    для объектов в ситуации когда не все методы интерфейса
    поддерживаются логически.

    это отметка того что систему интерфейсов требуется
    пересматривать, в том числе для интерфейсов
    вводя логические дробления.

    если такая ситуация возникает - дробить интерфейс
    на части,
    заменяя дробимый интерфейс на интерфейс с новым именем
    вводя вместо старого интерфейса корректный
    к которому уже и делать "implements" для имеющихся объектов

    при проектировании интерфейсов избегать
    ситуации когда два логических НЕ СВЯЗАННЫХ действия подразумеваются в одном
    интерфейсе.

    Пример на возможностях объектов:
    (группа возможностей - отличный путь раздробления интерфейсов)
    interface WeaponAbilities
    {
        void attack()
        void reload()
    }
    class Pistol implements WeaponAbilities
    {
        void attack()
        void reload()
    }
    - не корректно -
    class Pistol implements WeaponAbilities
    - корректно -
    class Pistol implements FireArmAttackAbility, FireArmReloadAbility

    --  Итоговый вариант кода в судо:
    ---------------------------------
    Естественно в реальной ситуации
    методом будет больше чем один
    однако наша логическая структура диктует
    именно такое:

    interface DoSomethingOne
    {
        void methodOne();
    }
    interface DoSomethingTwo
    {
        void methodTwo();
    }
    interface DoSomethingThree
    {
        void methodThree();
    }
    <- поддержка старого поведения для совместимости уже имеющегося кода:
    interface DoSomethingOneOldBehaviour implements DoSomethingOne, DoSomethingTwo, DoSomethingThree {}

    class One implements DoSomethingOneOldBehaviour {}
    class Two implements DoSomethingOne, DoSomethingTwo {}
    class Three implements DoSomethingOne, DoSomethingTwo {}
