
    Принцип 03: LISKOV_SUBSTITUTION_PRINCIPLE:
----------------------------------------------
    --  Описание принципа:
    ----------------------
    Подставив суб класс в метод
    где требуется супер класс мы получим
    предсказуемое поведение свойственное супер классу.

    то есть расширенный класс суб объекта
    ведет себя в методе где подразумевается генерализация
    (суб класс заменяет супер класс)
    корректно и предсказуемо.

    Прозрачная структура против непрозрачных контроллеров.

    Реализуется через корректное дробления супер классов
    на логические ветви таким образом
    (декомпозиция супер класса)
    чтобы исключить появление артефактов, чей функционал
    не задействован в том или ином классе, или
    что поведение в ситуации суб класса невозможно.

    --  Ситуация создающая проблему:
    --------------------------------
    class DataBase
    {
        connect(){}
        read(){}
        write(){}
        joinTables(){}
    }
    class MySqlDB extends DataBase
    {
        connect(){}
        read(){}
        write(){}
        joinTables(){}
    }
    class MongoDB extends DataBase
    {
        connect(){}
        read(){}
        write(){}
        joinTables(){}      <- нелогическое включение метода
        {
            throw new Error("у Mongo нет таблиц");
        }
    }

    На момент включения MongoDB класса
    поведение всей программы написаной до момента включения такого класса
    ставиться под сомнение, и его придется перепроверять.

    --  Предлагаемое решение:
    -------------------------
    только расширять, обязательно поддерживать совместимость на уровне супер класса.
    там где наследование нарушается вводить промежуточные классы
    которыми будем дробить систему наследования на ветви и субветви.

    --  Итоговый вариант кода в судо:
    ---------------------------------
    class DataBase                          <- все что касается специфичной ветви убрано из класса
    {
        connect(){}
        read(){}
        write(){}
    }
                                            <- здесь супер класс разбивается на два
    class SQLDataBase extends DataBase      <- появилась логически корректная ветка наследования
    {
        connect(){}
        read(){}
        write(){}
        joinTables(){}                      <- спорный метод переехал сюда (в ветвь где он уместен)
    }
    class MySqlDB extends SQLDataBase       <- наследование корректно (замена произведена супер класса на класс ветви)
    {
        connect(){}
        read(){}
        write(){}
        joinTables(){}
    }
          <- можно быть еще более последовательным и создать не MongoDB, а NoSqlDB
             в этом случае наследвоание станет еще и "ровным" логически (ветка дробления реально ветка
             разделяющая логику на два пути)
    class MongoDB extends DataBase          <- наследование снова корректно - спорного наследования просто нет
    {
        connect(){}
        read(){}
        write(){}
        createIndex(){}  <- метод сейчас здесь - но если будет нелогичная ветка - он будет перемещен в неё
    }
