
    Принцип 01: SINGLE_RESPONSIBILITY
-------------------------------------
    --  Описание принципа:
    ----------------------
    Один объект решает четко одну задачу,
    если объект решает несколько задач - то это сразу же антипаттерн

    1 класс -> 1 задача
    1 сущность -> 1 задача
    1 логика при создании -> 1 логика при изменениях объекта

    ответ на вопрос:
        "что я делаю?"
    дает один четкий вариант
    (возможны вариации, опции, но ответ все же один)
        Что я делаю:
            создаю форму вывода
        нужно:
            добавить вывод формы на английском языке
            вопрос - сохранился -> это опция

    В итоге использования принципа должны получить:
        1. Появились модули (декомпозиция), читабельность выросла
        2. Вносить изменения стало проще (код стал менее связаный)
        3. Избавились от антипаттерна GodObject
        4. Класс инкапсулирует решение одной задачи
        5. Увеличился "запас изменений" кода

    Объект не может одновременно и считать и записывать результаты
    вычисления в файл, он или считает - или записывает результаты
    вычислений в файл.

    --  Ситуация создающая проблему:
    --------------------------------
    был класс:
    <class>
    ClassName
        field1
        field2
        getField1()
        getField2()

    класс решили научить сохранять себя:
    <class>
    ClassName
        field1
        field2
        getField1()
        getField2()
        + save() - сохранение в базу данных
        + send() - отправка по http

    теперь решили добавить еще и методы вывода состояния
    и логирования:
    <class>
    ClassName
        field1
        field2
        getField1()
        getField2()
        save()
        send()
        + print() - выводит свое состояние
        + log() - логирует себя куда то

    вопрос: что делает этот класс?
    в какую сторону он может рости?
    может ли он жить в рамках наследования?
    понятно ли появление класса - в коде тем что хочет этот код делать?
    ответ - нет.

    --  Предлагаемое решение:
    -------------------------
    Принципиально заняться дроблением класса
    по логике работы контроллера - отвечая на вопрос "что я делаю?"
    получиться:
        1. что я делаю: храню данные и предоставляю данные другим
        2. что я делаю: сохраняю данные объекта хранящего данные в файл
        3. что я делаю: отправляю данные объекта хранящего данные по хттп
        4. что я делаю: печатаю данные объекта хранящего данные
        5. что я делаю: логирую объект храняший данные
    --
    Еще пример:

    (0) Форма создания реквизитов - ок
    (1) добавляется создание реквизитов на иностранном языке - пока терпимо (похоже на опцию)
    (2) форма создания реквизитов, обновления реквизитов - проблемы начинаются
        требуется разбивать на разные объекты.

    Объект отвечает на вопрос:
        я объект создан для ... во мне для этого есьт логика - вот она: ...
        она разбита на методы внутри объекта, никакой другой логики
        и цели использования объекта здесь нет
    как только получается
        я объект создан для ... а еще я умею .... и мною пользуются для ...
        у меня для этого есть один набор логики ..
        второй набор логики ...
        третий набор логики ...
    это проблема и объект должен быть разбит на части,
    связанные интерфейсами.

    --  Итоговый вариант кода в судо:
    ---------------------------------
    // может показаться что ситуация стала сильно сложной,
    // однако это не так - части логики кода - разместились ровно там где нужно
    // и код стал более читабельным:

    <interface>                                -- контракт для общения с дата классом
    ClassNameInterface
        getField1()
        getField2()

    <interface>                                -- интерфейс для распечатки
    ClassNamePrintable
        getPrintableString()

    <class>                                    -- дата класс
    ClassName implements ClassNameInterface, ClassNamePrintable
        field1
        field2
        getField1()
        getField2()
        getPrintableString()

    <class>
    ClassNameSaveManager                        -- менеджер сохранения (использует интерфейс получения данных)
        save(ClassNameInterface classToSave)

    <class>
    ClassNameHTTPSender                         -- отправляльщик класса (использует интерфейс получения данных)
        send(ClassNameInterface classToSend)

    <class>                                     -- логгер (использует интерфейс получения данных)
    ClassNameLoggerManager
        log(ClassNameInterface classToLog)
        + logToExcel                            -- модификации стали легко доступными
        + logToCSV

    <class>                                     -- распечатывальщик, использует интерфейс печати
    ClassNamePrinterManager
        print(ClassNamePrintable classToPrint)
