
    Принцип 05: DEPENDENCY_INVERSION_PRINCIPLE:
-----------------------------------------------
    --  Описание принципа:
    ----------------------
    Модули высокого уровня (генерализация: супер классы)
    не должны зависеть от модулей (суб классы)
    более низкого уровня

    Все они должны зависеть от абстракций (интерфейсов, абстрактных классов),
    а абстракции должны зависеть в свою очередь от деталей (наличия методов)

    И нечего вставлять объекты классов внутрь других классов, если уж
    что то должно быть в чем то - то это интерфейс, к которому цепляется
    через DependencyInjection что либо, а не отдельный объект
    (так программа всегда будет работать правильно и не будет ломаться).

    --  Ситуация создающая проблему:
    --------------------------------
    класс Работник          <- привязка к Деталь1
        работатьСДеталь1
        работатьСДеталь2
    класс Станок
        объект Деталь1      <- связан и с Работник и с Электричество
        объект Деталь2
    класс Электричество
        датьЭлектричествоДеталь1
        датьЭлектричествоДеталь2

    Деталь1 заменяется на Деталь3
    класс Работник с ней работать не может, параметры
    Электричества для Деталь3 придется прописывать отдельно
    и придется вводить новые методы.

    то есть из за ОДНОЙ детали придется менять
    и модуль Работник, и переписывать Станок, и
    менять класс Электричество.

    то есть выбытие внутренней логики породило
    слом логики всей системы в целом.

    --  Предлагаемое решение:
    -------------------------
    Перестроить работу моделей таким образом
    чтобы выдача работы от класса Работник и Электричество
    не зависели от объектов класса Станок

    то есть проще говоря на границах связей объектов
    передавать работу, а не внутри объектов
    - и -
    ни в коем случае не переносить логику обработки нижних объектов
    в верхние - подразумевая что нижние объекты плодятся
    а верхнему придется работать с ново появившимися.

    Работник будет продолжать работать через интерфейс
    со Станком не завися от того с какой Деталью он взаимодействует

    В итоге структура не будет втаскивать в себя
    внутри действия контроллеров и будет содержать
    максимально независимые друг от друга объекты.

    --  Итоговый вариант кода в судо:
    ---------------------------------

    Класс Электричество         <- прямая модификация с отвязкою зависимости
        выдатьНаряжениеПоПараметрам

    Класс Работник
        работатьВПринципеСПультом
    Класс Пульт                <- модификация через промежуточный объект/интерфейс (абстракция)
        работатьВПринципеСоСтанком(Станок станок) через интерфейс

    Класс Станок имплементирует интерфейсПультУправления
        объект Деталь1
        объект Деталь2
        --
        получитьЭлектричество(Электричество откудаПолучать) <- Электричество верхний уровень к Станку
        обеспечитьРаботу(ПультУправления пультУправления) <- ПультУправления верхний уровень к Станку

    -- еще пример --
    ----------------
    В итоге имеем:
    ----
    (01) Сам объект
    (02) Интерфейс его взаимодействия с внешним миром
        <- хотя бы одинаковое название методов
           (но это проблему не решит целиком - методы вызывают где?)
           (контракт API)
    (03) DependencyInjection поддерживающий объект в котором есть этот интерфейс
        <- хотя бы место куда искать идти то с чем работать придется, не плодить объекты
           (здесь уже законченное решение - методы вызываются ЗДЕСЬ)
           (звено между API и клиентами)
    (04) Сами в себе реализации интерфейса - со своей логикою
        <- этот кусок вообще отвязан на уровне логики от внешнего мира, он не знает ни о постах, ни об
           объекте - что будет его вызывать
           (API)
    (05) Контроллер
           (это уже выходит клиент)
    ----------------
    Post                <- внутренний элемент для логики
        id
        title
        content

    <interface>
    Repository          <- абстракция для взаимодействия его с внешним миром
        getAll
        getOne
        add

    <class>
    Storage implements Repository               <- реальный объект с которым будет взаимодействие
        constructor(repo: Repository)           <- DependencyInjection с указанием того с чем работать
        getAll
        getOne
        add

    <class>
    PostLocalStorage implements Repository      <- первый вариант реализации абстракции
        getAll
        getOne
        add
    <class>
    LocalStorage
        setItem
        getItem

    <class>
    PostDBRepository implements Repository      <- второй вариант реализации абстракции
        getAll
        getOne
        add
    <class>
    Postgres
        select
        insert